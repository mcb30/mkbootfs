#!/usr/bin/perl -w

=head1 NAME

    bootpack

=head1 SYNOPSIS

    bootpack [options] path[=new-path] [path[=new-path]... ]

    bootpack -o dev.bp /dev
    bootpack -o busybox.bp ./busybox-1.9.0/_install=/
    bootpack -o init.bp ./init.sh=/init
    bootpack -o modules.bp /lib/modules/`uname -r`
    cat dev.bp busybox.bp init.bp modules.bp > initrd.img

Options:

    -h,--help		Display brief help message
    -v,--verbose	Increase verbosity
    -q,--quiet		Decrease verbosity
    -o,--output=FILE	Create output package file FILE (default bootpack.bp)

=head1 DESCRIPTION

Create a boot package - a compressed cpio archive which can be used as
part of an initramfs image.  Boot packages may be simply concatenated
together to produce an initramfs image ready for use as a Linux
initial filesystem.

=head1 EXAMPLES

=item B< bootpack -o dev.bp /dev >

Create a boot package F<dev.bp> containing everything in the F</dev>
directory.

=item B< bootpack -o busybox.bp ./busybox-1.9.0/_install=/ >

Create a boot package F<busybox.bp> containing everything in the
F<./busybox-1.9.0/_install> directory, as though this were the root
directory.

=head1 OPTIONS

=item B< -o,--output=FILE >

Specify the output file.  If no output file is specified,
F<bootpack.bp> will be used.

=cut

use File::Find;
use File::stat;
use Compress::Zlib;
use Cwd qw ( realpath );
use POSIX qw ( S_ISREG );
use Getopt::Long;
use Pod::Usage;
use strict;
use warnings;

my $o;

##############################################################################
#
# Parse command line options into options hash ($o)

sub parse_opts {
  # $o is the hash that will hold the options
  my $o = {
    verbosity => 0,
    output => "bootpack.bp",
  };
  # Special handlers for some options
  my $opt_handlers = {
    verbose => sub { $o->{verbosity}++; },
    quiet => sub { $o->{verbosity}--; },
    help => sub { pod2usage(1); },
  };
  # Merge handlers into main options hash (so that Getopt::Long can find them)
  $o->{$_} = $opt_handlers->{$_} foreach keys %$opt_handlers;
  # Option specifiers for Getopt::Long
  my @optspec = ( 'help|h|?',
		  'quiet|q+',
		  'verbose|v+',
		  'output|o=s',
		  );
  # Do option parsing
  Getopt::Long::Configure ( 'bundling' );
  pod2usage ( "Error parsing command-line options" )
      unless GetOptions ( $o, @optspec );
  # Clean up $o by removing the handlers
  delete $o->{$_} foreach keys %$opt_handlers;

  return $o;
}

#############################################################################
#
# Process a file

sub cpio {
  my $realname = shift;
  my $name = shift;

  print STDERR "$realname => $name\n" if $o->{verbosity} >= 1;

  my $stat = lstat ( $realname )
      or die "Could not lstat $realname: $!\n";

  $name =~ s/^\///;
  my $namesize = ( length ( $name ) + 1 );
  my $cpio = sprintf ( "070701%08o%08o%08o%08o%08o%08o%08o%08o%08o".
		       "%08o%08o%08o00000000",
		       $stat->ino, $stat->mode,
		       0, 0, # flatten uid and gid
		       $stat->nlink, $stat->mtime,
		       $stat->size, $stat->maj, $stat->min,
		       $stat->rmaj, $stat->rmin, $namesize );
  $cpio .= $name."\0";
  $cpio .= "\0" x ( ( -$namesize ) % 4 );
  
  return $cpio;
}

#############################################################################
#
# Main program

$o = parse_opts ();
open my $out, ">$o->{output}"
    or die "Could not open output file $o->{output}: $!\n";

# Initialise compression stream
my $gz = gzopen ( $out, "w9" )
    or die "Cannot create gzip stream: $gzerrno\n";

while ( my $pathspec = shift ) {
  ( my $path, undef, my $newpath ) = ( $pathspec =~ /^(.*?)(=(.*))?$/ );
  $newpath = $path unless $newpath;
  print "$path => $newpath\n";
  find ( { no_chdir => 1,
	   follow_skip => 0,
	   wanted => sub {
	     my $realname = my $name = $_;
	     $name =~ s/^$path/$newpath/;
	     $name = realpath ( $name );
	     $gz->gzwrite ( cpio ( $realname, $name ) )
		 or die "Error writing to $o->{output}: $gzerrno\n";
	   }
	 }, $path );
}

$gz->gzclose();
close $out;

# Round up output file to a multiple of four bytes
my $stat = stat ( $o->{output} )
    or die "Could not stat output file $o->{output}: $!\n";
my $size = $stat->size;
my $newsize = ( ( $size + 3 ) & ~3 );
if ( $size != $newsize ) {
  print STDERR "Padding $o->{output} from $size bytes to $newsize bytes\n"
      if $o->{verbosity} >= 1;
  truncate ( $o->{output}, $newsize )
      or die "Could not resize output file $o->{output}: $!\n";
}
